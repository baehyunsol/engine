---
date: [2023, 5, 13]
tags: [rust, compiler]
preview: The Rust compiler is very complicated. It consists of many modules, and it takes multiple steps to translate a human-readable programming language to a machine code. Though it's not necessary for typical programmers to know the internals of the compiler, it'd be very helpful if we understand how the language works.
---

# IRs of Rust

The Rust compiler is very complicated. It consists of many modules, and it takes multiple steps to translate a human-readable programming language to a machine code. Though it's not necessary for typical programmers to know the internals of the compiler, it'd be very helpful if we understand how the language works. In this article, I'll take a closer look at the steps the compiler takes.

[Rust playground](https://play.rust-lang.org) is an excellent place to play around with the compiler-internals. All the IRs in this article are generated by it. I used Rust-1.71.0-nightly, which is the newest version as I write this article.

## Steps of the compilation

When a programmer compiles a Rust code, the code goes through below steps.

```
          Rust
           |
           | Lexer, Parser
           V
  Abstract Syntax Tree
           |
           | Rust Compiler
           V
          HIR
           |
           | Rust Compiler
           V
          MIR
           |
           | Rust Compiler
           V
        LLVM IR
           |
           | LLVM
           V
      Machine Code
```

First, a [lexer] translates a human-readable code to machine-friendly tokens. The tokens are then translated to [AST] by a [parser]. Lexing, parsing and AST are not Rust-specific concepts, so I won't discuss them in this article. If you want to know about them, please refer to the wikipedia links in the article.

The AST is translated to HIR, High-level Intermediate Representation. According to the [documentation][Rust Compiler Overview], HIR is a compiler-friendly AST. It resembles the syntax of Rust very closely, except that it's simplified. HIR is lowered to THIR, Typed High-level Intermediate Representation before converted to MIR. HIR is still quite readable to human. You'll see that in later sections.

The next step is MIR, Mid-level Intermediate Representation. It's a very simplified form. Many optimizations and safety checks are done in this stage. There are [blog post](https://blog.rust-lang.org/2016/04/19/MIR.html) and [documents](https://rustc-dev-guide.rust-lang.org/mir/index.html) explaining the details of MIR; you'd probably enjoy it.

After the compiler does Rust-specific analysis and optimizations on MIR, it's passed to LLVM. From here, everything is up to LLVM, which we're not interested in.

Most information in this section is from [Rust Compiler Overview]. Please refer to the document if you want to know more about the compiler.

[lexer]: https://en.wikipedia.org/wiki/Lexical_analysis
[parser]: https://en.wikipedia.org/wiki/Parsing#Parser
[AST]: https://en.wikipedia.org/wiki/Abstract_syntax_tree
[Rust Compiler Overview]: https://rustc-dev-guide.rust-lang.org/overview.html

[[box]]

Table of contents

Since this article contains very long lines of code, I provide you a Toc here.

[[toc]]

[[/box]]

## HIR

There isn't much change in HIR compared to the original code. Let's see how the compiler translates the fizz-buzz code below to HIR.

```rust, line_num
fn main() {
    for i in 1..200 {
        if i % 15 == 0 { println!("fizzbuzz"); }
        else if i % 3 == 0 { println!("fizz"); }
        else if i % 5 == 0 { println!("buzz"); }
        else { println!("{i}"); }
    }
}
```

```rust, line_num
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
fn main() {
    {
        let _t = match #[lang = "into_iter"](#[lang = "Range"]{ start: 1, end: 200, }) {
            mut iter => loop {
                match #[lang = "next"](&mut iter) {
                    #[lang = "None"] {} => break,
                    #[lang = "Some"] {  0: i } => {
                        if i % 15 == 0 { {
                            ::std::io::_print(<#[lang = "format_arguments"]>::new_const(&["fizzbuzz\n"]));
                        }; }

                        else if i % 3 == 0 { {
                            ::std::io::_print(<#[lang = "format_arguments"]>::new_const(&["fizz\n"]));
                        }; }

                        else if i % 5 == 0 { {
                            ::std::io::_print(<#[lang = "format_arguments"]>::new_const(&["buzz\n"]));
                        }; }

                        else { {
                            ::std::io::_print(
                                <#[lang = "format_arguments"]>::new_v1(
                                    &["", "\n"],
                                    &[<#[lang = "format_argument"]>::new_display(&i)])
                                );
                        }; }
                    }
                }
            },
        };

        _t
    }
}
```

I ran the compiler in release mode, but the debug mode outputs the same HIR because it doesn't optimize when generating HIR.

The first change we notice is an import of preludes. It includes very frequently used names. You can see the exhaustive list of the preludes [here](https://doc.rust-lang.org/stable/std/prelude/index.html). Then, you can see tons of `#[lang = "XXX"]` macros. It looks scary at first, but they are just shortcuts for long names. For example, `#[lang = "Some"]` refers to `Option::Some<T>` defined in the std library. Possible variants of the macro is defined [here](https://github.com/rust-lang/rust/blob/master/compiler/rustc_hir/src/lang_items.rs)[^nolineno]. The table is defined at the end of the code. I have no idea why they use such macro, but let's not get scared. With that in mind, we can understand the above code like below:

1. `1..200` is translated to `Range { start: 1, end: 200 }.into_iter()`.
2. `Range { start: 1, end: 200 }.into_iter()` is assigned to `iter`.
3. It turns `for` into `loop`. In each loop, it matches `iter.next()`
4. If `iter.next()` is `None`, it breaks.
5. If `iter.next()` is `Some(i)`, it runs the fizz-buzz code.
6. `println!` is converted to `::std::io::_print`. You can see the definition of `_print` [here](https://github.com/rust-lang/rust/blob/master/library/std/src/io/stdio.rs)[^nolineno].

[^nolineno]: I didn't include the line number, cause it may change over time.

## MIR

### Example 1: Push an element to a vector

I tried MIR with the fizz-buzz code above, but it was too long. I don't want you guys to suffer scrolling the endless code, so I'll use shorter code.

```rust, line_num
fn main() {
    let mut a = vec![1, 2, 3, 4];
    a.push(5);
}
```

Only 2 lines. I want to see how vector initializaion and push operation are expressed in MIR. Before looking at the MIR, looking at the HIR would be helpful.

```rust, line_num
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;

fn main() {
    let mut a = <[_]>::into_vec(
        #[rustc_box] ::alloc::boxed::Box::new([1, 2, 3, 4])
    );

    a.push(5);
}
```

It turns `vec!` into `into_vec(Box::new())`. See the documents of [Box](https://doc.rust-lang.org/stable/std/boxed/index.html) and [into_vec](https://github.com/rust-lang/rust/blob/master/library/alloc/src/slice.rs)[^nolineno] if you wanna know further.

Below is the MIR of the above code, generated in Debug mode.

[[anchor, id=mir ex1]][[/anchor]]

```rust, line_num
// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn main() -> () {
    let mut _0: ();                      // return place in scope 0 at src/main.rs:1:11: 1:11
    let mut _1: std::vec::Vec<i32>;      // in scope 0 at src/main.rs:2:9: 2:14
    let mut _2: std::boxed::Box<[i32]>;  // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
    let mut _3: usize;                   // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
    let mut _4: usize;                   // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
    let mut _5: *mut u8;                 // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
    let mut _6: std::boxed::Box<[i32; 4]>; // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
    let _7: ();                          // in scope 0 at src/main.rs:3:5: 3:14
    let mut _8: &mut std::vec::Vec<i32>; // in scope 0 at src/main.rs:3:5: 3:14
    let mut _9: *const [i32; 4];         // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
    let mut _10: *const ();              // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
    let mut _11: usize;                  // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
    let mut _12: usize;                  // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
    let mut _13: usize;                  // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
    let mut _14: usize;                  // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
    let mut _15: bool;                   // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
    scope 1 {
        debug a => _1;                   // in scope 1 at src/main.rs:2:9: 2:14
    }
    scope 2 {
    }

    bb0: {
        _3 = SizeOf([i32; 4]);           // scope 2 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
        _4 = AlignOf([i32; 4]);          // scope 2 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
        _5 = alloc::alloc::exchange_malloc(move _3, move _4) -> bb1; // scope 2 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
                                         // mir::Constant
                                         // + span: /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
                                         // + literal: Const { ty: unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}, val: Value(<ZST>) }
    }

    bb1: {
        _6 = ShallowInitBox(move _5, [i32; 4]); // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
        _9 = (((_6.0: std::ptr::Unique<[i32; 4]>).0: std::ptr::NonNull<[i32; 4]>).0: *const [i32; 4]); // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
        _10 = _9 as *const () (PtrToPtr); // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
        _11 = _10 as usize (Transmute);  // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
        _12 = AlignOf(i32);              // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
        _13 = Sub(_12, const 1_usize);   // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
        _14 = BitAnd(_11, _13);          // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
        _15 = Eq(_14, const 0_usize);    // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
        assert(_15, "misaligned pointer dereference: address must be a multiple of {} but is {}", _12, _11) -> [success: bb7, unwind terminate]; // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
    }

    bb2: {
        _8 = &mut _1;                    // scope 1 at src/main.rs:3:5: 3:14
        _7 = Vec::<i32>::push(move _8, const 5_i32) -> [return: bb3, unwind: bb5]; // scope 1 at src/main.rs:3:5: 3:14
                                         // mir::Constant
                                         // + span: src/main.rs:3:7: 3:11
                                         // + literal: Const { ty: for<'a> fn(&'a mut Vec<i32>, i32) {Vec::<i32>::push}, val: Value(<ZST>) }
    }

    bb3: {
        drop(_1) -> bb4;                 // scope 0 at src/main.rs:4:1: 4:2
    }

    bb4: {
        return;                          // scope 0 at src/main.rs:4:2: 4:2
    }

    bb5 (cleanup): {
        drop(_1) -> [return: bb6, unwind terminate]; // scope 0 at src/main.rs:4:1: 4:2
    }

    bb6 (cleanup): {
        resume;                          // scope 0 at src/main.rs:1:1: 4:2
    }

    bb7: {
        (*_9) = [const 1_i32, const 2_i32, const 3_i32, const 4_i32]; // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
        _2 = move _6 as std::boxed::Box<[i32]> (Pointer(Unsize)); // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
        _1 = slice::<impl [i32]>::into_vec::<std::alloc::Global>(move _2) -> bb2; // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:50:36: 55:10
                                         // mir::Constant
                                         // + span: /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:50:36: 50:51
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(Box<[i32]>) -> Vec<i32> {slice::<impl [i32]>::into_vec::<std::alloc::Global>}, val: Value(<ZST>) }
    }
}
```

A function in MIR consists of locals, scopes and basic blocks.

Locals are values stored on the stack, such as function arguments, local variables and temporary variables. They're underscored numbers. `_0` is the return value of the function. In our code, `_0` is `()` because the main function doesn't return anything. `a` in Rust is assigned to `_1` in MIR. `_2` through `_6` are temporary variables used by the `vec!` macro. `_7` is the return value of `.push` method. Since it returns nothing, `_7`'s type is `()`.

After locals, there are scopes. They represent lexical scopes. They also contains debug information, which you can see in `scope 1` above. It says `a` is the name of `_1`. Scopes include all the debug information of user-defined variables.

Then you see basic blocks. They represent the control flow of the code. The flow starts at `bb0`, which stands for *basic block 0*. Each basic block contains one or more statements. The last statement is called terminator. The terminator tells which block to execute next. We call the next block *successor*. A block may have more than one successor.

`bb0` allocates memory for `a` using [exchange_malloc](https://github.com/rust-lang/rust/blob/master/library/alloc/src/alloc.rs)[^nolineno] and stores the pointer at `_5`. `-> bb1` after the terminator means it should go to `bb1` after executing `bb0`.

`bb1` initializes a `Box` pointer using the pointer from the previous block and checks whether the pointer is well aligned. If so, it goes to `bb7`. Otherwise, it terminates. The two successors are in squared brackets after the terminator.

`bb7` initializes the vector, and `bb2` pushes an element. After everything is done, the runtime calls the destructor of the vector by dropping it, then terminates.

Most statements in basic blocks are assignments of an [RValue] to a [Place]. A [Place] is a location in memory. It consists of a local and [Projection]s. A projection can be a deref, index, field, .. etc. Anything that comes at the right-hand side of `=` can be an [RValue]. Note that it only defines simple forms. For complex operations like `*_2 + *_3 + *_4`, it uses multiple statements and temporary variables.

Let's look at [RValue] more closely. One of the most frequently used variant is [BinaryOp](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.Rvalue.html#variant.BinaryOp). You'll see it throughout this article. You already saw them at line 41 and 43 above. The variant consists of a [BinOp] and two [Operand]s. The [BinOp] enum defines primitive arithmetic operators including add, sub, mul and div. The [Operand] enum is literally an operand of all the operations of [RValue]. There are 3 kinds of [Operand]s: Copy, Move and Constant. Copy and Move represents the copy semantics and the move semantics of Rust. All the [Place]s appear in [RValue] must be either copy, move or constant. You can see that many operands in the above MIR are prefixed with `const` or `move`. Operands without any prefix are copied ones. For example, the first operand of line 41 (`_12`) is copied and the second one (`const 1_usize`) is a constant.

[RValue]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.Rvalue.html
[Place]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/struct.Place.html
[Operand]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.Operand.html
[BinOp]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/syntax/enum.BinOp.html
[Projection]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.ProjectionElem.html

[[br]]

What if we run the same code in release mode?

[[anchor, id=mir ex2]][[/anchor]]

```rust, line_num
// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn main() -> () {
    let mut _0: ();                      // return place in scope 0 at src/main.rs:1:11: 1:11
    let mut _1: std::vec::Vec<i32>;      // in scope 0 at src/main.rs:2:9: 2:14
    let mut _2: std::boxed::Box<[i32]>;  // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
    let mut _3: usize;                   // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
    let mut _4: usize;                   // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
    let mut _5: *mut u8;                 // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
    let mut _6: std::boxed::Box<[i32; 4]>; // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
    let _7: ();                          // in scope 0 at src/main.rs:3:5: 3:14
    let mut _8: &mut std::vec::Vec<i32>; // in scope 0 at src/main.rs:3:5: 3:14
    let mut _9: *const [i32; 4];         // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
    scope 1 {
        debug a => _1;                   // in scope 1 at src/main.rs:2:9: 2:14
    }
    scope 2 {
    }
    scope 3 (inlined slice::<impl [i32]>::into_vec::<std::alloc::Global>) { // at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:50:36: 55:10
        debug self => _2;                // in scope 3 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/slice.rs:461:35: 461:39
    }

    bb0: {
        StorageLive(_1);                 // scope 0 at src/main.rs:2:9: 2:14
        StorageLive(_2);                 // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
        _3 = const 16_usize;             // scope 2 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
        _4 = const 4_usize;              // scope 2 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
        _5 = alloc::alloc::exchange_malloc(move _3, move _4) -> bb1; // scope 2 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
                                         // mir::Constant
                                         // + span: /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
                                         // + literal: Const { ty: unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}, val: Value(<ZST>) }
    }

    bb1: {
        _6 = ShallowInitBox(move _5, [i32; 4]); // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
        _9 = (((_6.0: std::ptr::Unique<[i32; 4]>).0: std::ptr::NonNull<[i32; 4]>).0: *const [i32; 4]); // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
        (*_9) = [const 1_i32, const 2_i32, const 3_i32, const 4_i32]; // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
        _2 = move _6 as std::boxed::Box<[i32]> (Pointer(Unsize)); // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
        _1 = slice::hack::into_vec::<i32, std::alloc::Global>(move _2) -> bb6; // scope 3 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/slice.rs:463:9: 463:29
                                         // mir::Constant
                                         // + span: /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/slice.rs:463:9: 463:23
                                         // + literal: Const { ty: fn(Box<[i32]>) -> Vec<i32> {slice::hack::into_vec::<i32, std::alloc::Global>}, val: Value(<ZST>) }
    }

    bb2: {
        StorageDead(_8);                 // scope 1 at src/main.rs:3:13: 3:14
        drop(_1) -> bb3;                 // scope 0 at src/main.rs:4:1: 4:2
    }

    bb3: {
        StorageDead(_1);                 // scope 0 at src/main.rs:4:1: 4:2
        return;                          // scope 0 at src/main.rs:4:2: 4:2
    }

    bb4 (cleanup): {
        drop(_1) -> [return: bb5, unwind terminate]; // scope 0 at src/main.rs:4:1: 4:2
    }

    bb5 (cleanup): {
        resume;                          // scope 0 at src/main.rs:1:1: 4:2
    }

    bb6: {
        StorageDead(_2);                 // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:55:9: 55:10
        StorageLive(_8);                 // scope 1 at src/main.rs:3:5: 3:14
        _8 = &mut _1;                    // scope 1 at src/main.rs:3:5: 3:14
        _7 = Vec::<i32>::push(move _8, const 5_i32) -> [return: bb2, unwind: bb4]; // scope 1 at src/main.rs:3:5: 3:14
                                         // mir::Constant
                                         // + span: src/main.rs:3:7: 3:11
                                         // + literal: Const { ty: for<'a> fn(&'a mut Vec<i32>, i32) {Vec::<i32>::push}, val: Value(<ZST>) }
    }
}
```

It's way shorter! `bb0` doesn't calculate the size and the alignment of `[i32; 4]` anymore. I guess the compiler calculated it and hard-coded it. There are `StorageDead` and `StorageLive` functions which we didn't see in debug mode. `StorageLive(_1)` tells LLVM that `_1` may be used later. `StorageDead(_1)` means it won't be used anymore. It helps LLVM allocate stack space.

In release mode, it doens't check the alignment of the pointer anymore. It just initializes the vector in `bb1`.

Reference: [RustC Dev Guide](https://rustc-dev-guide.rust-lang.org/mir/index.html)

### Example 2: Adder

Let's do the same thing with another simple code.

```rust, line_num
fn main() {
    add(3, 4);
}

fn foo(a: i32, b: i32) -> i32 {
    if a > b { a + 1 } else { b + 1}
}
```

We don't need HIR this time: it's (almost) identical to the original code. Let's go directly to the MIR.

[[anchor, id=mir ex3]][[/anchor]]

```rust, line_num
// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn main() -> () {
    let mut _0: ();                      // return place in scope 0 at src/main.rs:1:11: 1:11
    let _1: i32;                         // in scope 0 at src/main.rs:2:5: 2:14

    bb0: {
        _1 = foo(const 3_i32, const 4_i32) -> bb1; // scope 0 at src/main.rs:2:5: 2:14
                                         // mir::Constant
                                         // + span: src/main.rs:2:5: 2:8
                                         // + literal: Const { ty: fn(i32, i32) -> i32 {foo}, val: Value(<ZST>) }
    }

    bb1: {
        return;                          // scope 0 at src/main.rs:3:2: 3:2
    }
}

fn foo(_1: i32, _2: i32) -> i32 {
    debug a => _1;                       // in scope 0 at src/main.rs:5:8: 5:9
    debug b => _2;                       // in scope 0 at src/main.rs:5:16: 5:17
    let mut _0: i32;                     // return place in scope 0 at src/main.rs:5:27: 5:30
    let mut _3: bool;                    // in scope 0 at src/main.rs:6:8: 6:13
    let mut _4: (i32, bool);             // in scope 0 at src/main.rs:6:16: 6:21
    let mut _5: (i32, bool);             // in scope 0 at src/main.rs:6:31: 6:36

    bb0: {
        _3 = Gt(_1, _2);                 // scope 0 at src/main.rs:6:8: 6:13
        switchInt(move _3) -> [0: bb3, otherwise: bb1]; // scope 0 at src/main.rs:6:8: 6:13
    }

    bb1: {
        _4 = CheckedAdd(_1, const 1_i32); // scope 0 at src/main.rs:6:16: 6:21
        assert(!move (_4.1: bool), "attempt to compute `{} + {}`, which would overflow", _1, const 1_i32) -> bb2; // scope 0 at src/main.rs:6:16: 6:21
    }

    bb2: {
        _0 = move (_4.0: i32);           // scope 0 at src/main.rs:6:16: 6:21
        goto -> bb5;                     // scope 0 at src/main.rs:6:5: 6:37
    }

    bb3: {
        _5 = CheckedAdd(_2, const 1_i32); // scope 0 at src/main.rs:6:31: 6:36
        assert(!move (_5.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_i32) -> bb4; // scope 0 at src/main.rs:6:31: 6:36
    }

    bb4: {
        _0 = move (_5.0: i32);           // scope 0 at src/main.rs:6:31: 6:36
        goto -> bb5;                     // scope 0 at src/main.rs:6:5: 6:37
    }

    bb5: {
        return;                          // scope 0 at src/main.rs:7:2: 7:2
    }
}

```

Above is its MIR in debug mode. Let's look at the `foo` function. Two parameters: `a` and `b` are assigned to `_1` and `_2`. You can see their debug info at the top of the function. Its return value is assigned to `_0`, as usual. `_3` is a temporary variable which stores the result of `a > b`.

In `bb0`, it computes the result of `a > b` and stores it at `_3`. If the result is 0, it goes to `bb3`. Otherwise, it goes to `bb1`. In `bb1` and `bb3`, it calls `CheckedAdd`, not just `Add`. The `CheckedAdd` function returns the result and whether it overflowed. That's why the type of `_4` and `_5` are `(i32, bool)`.

After that, it goes to `bb2` or `bb4` where it moves the result to `_0` and returns.

In release mode, it's way simpler. See below.

[[anchor, id=mir ex4]][[/anchor]]

```rust, line_num
// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn main() -> () {
    let mut _0: ();                      // return place in scope 0 at src/main.rs:1:11: 1:11
    let _1: i32;                         // in scope 0 at src/main.rs:2:5: 2:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/main.rs:2:5: 2:14
        _1 = foo(const 3_i32, const 4_i32) -> bb1; // scope 0 at src/main.rs:2:5: 2:14
                                         // mir::Constant
                                         // + span: src/main.rs:2:5: 2:8
                                         // + literal: Const { ty: fn(i32, i32) -> i32 {foo}, val: Value(<ZST>) }
    }

    bb1: {
        StorageDead(_1);                 // scope 0 at src/main.rs:2:14: 2:15
        return;                          // scope 0 at src/main.rs:3:2: 3:2
    }
}

fn foo(_1: i32, _2: i32) -> i32 {
    debug a => _1;                       // in scope 0 at src/main.rs:5:8: 5:9
    debug b => _2;                       // in scope 0 at src/main.rs:5:16: 5:17
    let mut _0: i32;                     // return place in scope 0 at src/main.rs:5:27: 5:30
    let mut _3: bool;                    // in scope 0 at src/main.rs:6:8: 6:13

    bb0: {
        StorageLive(_3);                 // scope 0 at src/main.rs:6:8: 6:13
        _3 = Gt(_1, _2);                 // scope 0 at src/main.rs:6:8: 6:13
        switchInt(move _3) -> [0: bb2, otherwise: bb1]; // scope 0 at src/main.rs:6:8: 6:13
    }

    bb1: {
        _0 = Add(_1, const 1_i32);       // scope 0 at src/main.rs:6:16: 6:21
        goto -> bb3;                     // scope 0 at src/main.rs:6:5: 6:37
    }

    bb2: {
        _0 = Add(_2, const 1_i32);       // scope 0 at src/main.rs:6:31: 6:36
        goto -> bb3;                     // scope 0 at src/main.rs:6:5: 6:37
    }

    bb3: {
        StorageDead(_3);                 // scope 0 at src/main.rs:6:36: 6:37
        return;                          // scope 0 at src/main.rs:7:2: 7:2
    }
}
```

I have no idea why `StorageLive` and `StorageDead` only appear in release mode. It's almost identical to the previous MIR, except that it doesn't check the overflow.

### Example 3: Hello World

```rust
fn main() {
    println!("Hello World!");
}
```

Let's go straight to the MIR.

```rust, line_num
// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn main() -> () {
    let mut _0: ();                      // return place in scope 0 at src/main.rs:1:11: 1:11
    let _1: ();                          // in scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/std/src/macros.rs:137:9: 137:62
    let mut _2: std::fmt::Arguments<'_>; // in scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/std/src/macros.rs:137:28: 137:61
    let mut _3: &[&str];                 // in scope 0 at src/main.rs:2:14: 2:28
    let mut _4: &[core::fmt::ArgumentV1<'_>]; // in scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/std/src/macros.rs:137:28: 137:61
    let mut _5: &[core::fmt::ArgumentV1<'_>; 0]; // in scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/std/src/macros.rs:137:28: 137:61
    let mut _6: &[&str; 1];              // in scope 0 at src/main.rs:2:14: 2:28

    bb0: {
        _6 = const _;                    // scope 0 at src/main.rs:2:14: 2:28
                                         // mir::Constant
                                         // + span: src/main.rs:2:14: 2:28
                                         // + literal: Const { ty: &[&str; 1], val: Unevaluated(main, [], Some(promoted[1])) }
        _3 = _6 as &[&str] (Pointer(Unsize)); // scope 0 at src/main.rs:2:14: 2:28
        _5 = const _;                    // scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/std/src/macros.rs:137:28: 137:61
                                         // mir::Constant
                                         // + span: /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/std/src/macros.rs:137:28: 137:61
                                         // + literal: Const { ty: &[core::fmt::ArgumentV1<'_>; 0], val: Unevaluated(main, [], Some(promoted[0])) }
        _4 = _5 as &[core::fmt::ArgumentV1<'_>] (Pointer(Unsize)); // scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/std/src/macros.rs:137:28: 137:61
        _2 = Arguments::<'_>::new_v1(move _3, move _4) -> bb1; // scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/std/src/macros.rs:137:28: 137:61
                                         // mir::Constant
                                         // + span: /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/std/src/macros.rs:137:28: 137:61
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(&[&'static str], &[core::fmt::ArgumentV1<'_>]) -> Arguments<'_> {Arguments::<'_>::new_v1}, val: Value(<ZST>) }
    }

    bb1: {
        _1 = _print(move _2) -> bb2;     // scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/std/src/macros.rs:137:9: 137:62
                                         // mir::Constant
                                         // + span: /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/std/src/macros.rs:137:9: 137:27
                                         // + literal: Const { ty: for<'a> fn(Arguments<'a>) {_print}, val: Value(<ZST>) }
    }

    bb2: {
        return;                          // scope 0 at src/main.rs:3:2: 3:2
    }
}

promoted[0] in main: &[core::fmt::ArgumentV1<'_>; 0] = {
    let mut _0: &[core::fmt::ArgumentV1<'_>; 0]; // return place in scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/std/src/macros.rs:137:28: 137:61
    let mut _1: [core::fmt::ArgumentV1<'_>; 0]; // in scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/std/src/macros.rs:137:28: 137:61

    bb0: {
        _1 = [];                         // scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/std/src/macros.rs:137:28: 137:61
        _0 = &_1;                        // scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/std/src/macros.rs:137:28: 137:61
        return;                          // scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/std/src/macros.rs:137:28: 137:61
    }
}

promoted[1] in main: &[&str; 1] = {
    let mut _0: &[&str; 1];              // return place in scope 0 at src/main.rs:2:14: 2:28
    let mut _1: [&str; 1];               // in scope 0 at src/main.rs:2:14: 2:28

    bb0: {
        _1 = [const "Hello World!\n"];   // scope 0 at src/main.rs:2:14: 2:28
                                         // mir::Constant
                                         // + span: src/main.rs:2:14: 2:28
                                         // + literal: Const { ty: &str, val: Value(Slice(..)) }
        _0 = &_1;                        // scope 0 at src/main.rs:2:14: 2:28
        return;                          // scope 0 at src/main.rs:2:14: 2:28
    }
}
```

Interesting that Hello World generates this long MIR. There are `promoted` blocks which we haven't seen before. Constants in MIR are stored in a `promoted` vector. The `promoted` blocks initialize the constants. For example, line 13 above assigns a constant to `_6`, but it doesn't tell us what the constant is. If you read the comments carefully, it says the value can be found in `promoted[1]`. In the `promoted[1]` block, it initializes `const "Hello World!\n"`.

### Example 4: Drop Elaboration

```rust, line_num
fn main() {
    let mut y = vec![1, 2, 3, 4];

    {
        let x = vec![5, 6, 7, 8];

        if std::process::id() % 2 == 0 {
            y = x;
        }

    }
}
```

The code above is from [rustc-dev-guide](https://rustc-dev-guide.rust-lang.org/mir/drop-elaboration.html). MIR implements a special flag called "drop flag". It's used to track dynamic drops. In the above code, the compiler cannot know whether `y = x;` will be executed or not. That means the compiler does not know when to drop `[1, 2, 3, 4]`. Let's see how the compiler deals with this problem. Below is the MIR of the above code in release mode.

```rust, line_num
// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn main() -> () {
    let mut _0: ();                      // return place in scope 0 at src/main.rs:1:11: 1:11
    let mut _1: std::vec::Vec<i32>;      // in scope 0 at src/main.rs:2:9: 2:14
    let mut _2: std::boxed::Box<[i32]>;  // in scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:54:13: 54:47
    let mut _3: usize;                   // in scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:54:13: 54:47
    let mut _4: usize;                   // in scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:54:13: 54:47
    let mut _5: *mut u8;                 // in scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:54:13: 54:47
    let mut _6: std::boxed::Box<[i32; 4]>; // in scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:54:13: 54:47
    let mut _8: std::boxed::Box<[i32]>;  // in scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:54:13: 54:47
    let mut _9: usize;                   // in scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:54:13: 54:47
    let mut _10: usize;                  // in scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:54:13: 54:47
    let mut _11: *mut u8;                // in scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:54:13: 54:47
    let mut _12: std::boxed::Box<[i32; 4]>; // in scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:54:13: 54:47
    let mut _13: u32;                    // in scope 0 at src/main.rs:7:12: 7:34
    let mut _14: u32;                    // in scope 0 at src/main.rs:7:12: 7:30
    let mut _15: std::vec::Vec<i32>;     // in scope 0 at src/main.rs:8:17: 8:18
    let mut _16: bool;                   // in scope 0 at src/main.rs:11:5: 11:6
    let mut _17: *const [i32; 4];        // in scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:54:13: 54:47
    let mut _18: *const [i32; 4];        // in scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:54:13: 54:47
    scope 1 {
        debug y => _1;                   // in scope 1 at src/main.rs:2:9: 2:14
        let _7: std::vec::Vec<i32>;      // in scope 1 at src/main.rs:5:13: 5:14
        scope 3 {
            debug x => _7;               // in scope 3 at src/main.rs:5:13: 5:14
        }
        scope 4 {
        }
        scope 6 (inlined slice::<impl [i32]>::into_vec::<std::alloc::Global>) { // at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:50:36: 55:10
            debug self => _8;            // in scope 6 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/slice.rs:461:35: 461:39
        }
    }
    scope 2 {
    }
    scope 5 (inlined slice::<impl [i32]>::into_vec::<std::alloc::Global>) { // at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:50:36: 55:10
        debug self => _2;                // in scope 5 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/slice.rs:461:35: 461:39
    }

    bb0: {
        StorageLive(_1);                 // scope 0 at src/main.rs:2:9: 2:14
        StorageLive(_2);                 // scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:54:13: 54:47
        _3 = const 16_usize;             // scope 2 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:54:13: 54:47
        _4 = const 4_usize;              // scope 2 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:54:13: 54:47
        _5 = alloc::alloc::exchange_malloc(move _3, move _4) -> bb1; // scope 2 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:54:13: 54:47
                                         // mir::Constant
                                         // + span: /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:54:13: 54:47
                                         // + literal: Const { ty: unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}, val: Value(<ZST>) }
    }

    bb1: {
        _6 = ShallowInitBox(move _5, [i32; 4]); // scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:54:13: 54:47
        _17 = (((_6.0: std::ptr::Unique<[i32; 4]>).0: std::ptr::NonNull<[i32; 4]>).0: *const [i32; 4]); // scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:54:37: 54:46
        (*_17) = [const 1_i32, const 2_i32, const 3_i32, const 4_i32]; // scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:54:37: 54:46
        _2 = move _6 as std::boxed::Box<[i32]> (Pointer(Unsize)); // scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:54:13: 54:47
        _1 = slice::hack::into_vec::<i32, std::alloc::Global>(move _2) -> bb16; // scope 5 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/slice.rs:463:9: 463:29
                                         // mir::Constant
                                         // + span: /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/slice.rs:463:9: 463:23
                                         // + literal: Const { ty: fn(Box<[i32]>) -> Vec<i32> {slice::hack::into_vec::<i32, std::alloc::Global>}, val: Value(<ZST>) }
    }

    bb2: {
        _12 = ShallowInitBox(move _11, [i32; 4]); // scope 1 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:54:13: 54:47
        _18 = (((_12.0: std::ptr::Unique<[i32; 4]>).0: std::ptr::NonNull<[i32; 4]>).0: *const [i32; 4]); // scope 1 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:54:37: 54:46
        (*_18) = [const 5_i32, const 6_i32, const 7_i32, const 8_i32]; // scope 1 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:54:37: 54:46
        _8 = move _12 as std::boxed::Box<[i32]> (Pointer(Unsize)); // scope 1 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:54:13: 54:47
        _7 = slice::hack::into_vec::<i32, std::alloc::Global>(move _8) -> [return: bb17, unwind: bb9]; // scope 6 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/slice.rs:463:9: 463:29
                                         // mir::Constant
                                         // + span: /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/slice.rs:463:9: 463:23
                                         // + literal: Const { ty: fn(Box<[i32]>) -> Vec<i32> {slice::hack::into_vec::<i32, std::alloc::Global>}, val: Value(<ZST>) }
    }

    bb3: {
        _13 = Rem(move _14, const 2_u32); // scope 3 at src/main.rs:7:12: 7:34
        StorageDead(_14);                // scope 3 at src/main.rs:7:33: 7:34
        switchInt(move _13) -> [0: bb4, otherwise: bb5]; // scope 3 at src/main.rs:7:12: 7:39
    }

    bb4: {
        StorageDead(_13);                // scope 3 at src/main.rs:7:12: 7:39
        StorageLive(_15);                // scope 3 at src/main.rs:8:17: 8:18
        _16 = const false;               // scope 3 at src/main.rs:8:17: 8:18
        _15 = move _7;                   // scope 3 at src/main.rs:8:17: 8:18
        drop(_1) -> [return: bb12, unwind: bb11]; // scope 3 at src/main.rs:8:13: 8:14
    }

    bb5: {
        StorageDead(_13);                // scope 3 at src/main.rs:7:12: 7:39
        goto -> bb6;                     // scope 3 at src/main.rs:7:9: 9:10
    }

    bb6: {
        switchInt(_16) -> [0: bb7, otherwise: bb13]; // scope 1 at src/main.rs:11:5: 11:6
    }

    bb7: {
        StorageDead(_7);                 // scope 1 at src/main.rs:11:5: 11:6
        drop(_1) -> bb8;                 // scope 0 at src/main.rs:12:1: 12:2
    }

    bb8: {
        StorageDead(_1);                 // scope 0 at src/main.rs:12:1: 12:2
        return;                          // scope 0 at src/main.rs:12:2: 12:2
    }

    bb9 (cleanup): {
        drop(_1) -> bb10;                // scope 0 at src/main.rs:12:1: 12:2
    }

    bb10 (cleanup): {
        resume;                          // scope 0 at src/main.rs:1:1: 12:2
    }

    bb11 (cleanup): {
        _1 = move _15;                   // scope 3 at src/main.rs:8:13: 8:14
        goto -> bb15;                    // scope 3 at src/main.rs:8:13: 8:14
    }

    bb12: {
        _1 = move _15;                   // scope 3 at src/main.rs:8:13: 8:14
        StorageDead(_15);                // scope 3 at src/main.rs:8:17: 8:18
        goto -> bb6;                     // scope 3 at src/main.rs:7:9: 9:10
    }

    bb13: {
        drop(_7) -> [return: bb7, unwind: bb9]; // scope 1 at src/main.rs:11:5: 11:6
    }

    bb14 (cleanup): {
        drop(_7) -> bb9;                 // scope 1 at src/main.rs:11:5: 11:6
    }

    bb15 (cleanup): {
        switchInt(_16) -> [0: bb9, otherwise: bb14]; // scope 1 at src/main.rs:11:5: 11:6
    }

    bb16: {
        StorageDead(_2);                 // scope 0 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:55:9: 55:10
        StorageLive(_7);                 // scope 1 at src/main.rs:5:13: 5:14
        StorageLive(_8);                 // scope 1 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:54:13: 54:47
        _9 = const 16_usize;             // scope 4 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:54:13: 54:47
        _10 = const 4_usize;             // scope 4 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:54:13: 54:47
        _11 = alloc::alloc::exchange_malloc(move _9, move _10) -> [return: bb2, unwind: bb9]; // scope 4 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:54:13: 54:47
                                         // mir::Constant
                                         // + span: /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:54:13: 54:47
                                         // + literal: Const { ty: unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}, val: Value(<ZST>) }
    }

    bb17: {
        _16 = const true;                // scope 1 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:55:9: 55:10
        StorageDead(_8);                 // scope 1 at /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/alloc/src/macros.rs:55:9: 55:10
        StorageLive(_13);                // scope 3 at src/main.rs:7:12: 7:34
        StorageLive(_14);                // scope 3 at src/main.rs:7:12: 7:30
        _14 = id() -> [return: bb3, unwind: bb15]; // scope 3 at src/main.rs:7:12: 7:30
                                         // mir::Constant
                                         // + span: src/main.rs:7:12: 7:28
                                         // + literal: Const { ty: fn() -> u32 {id}, val: Value(<ZST>) }
    }
}
```

`_16` is the key here. The comment says `_16` is at `main.rs:11:5: 11:6`, but we don't see anything there. It's the special flag that MIR created to track the lifetime of `y` dynamically. You can see how it works in the Control Flow Graph below.

```
╭─────────────────────────────╮
│  bb0 -> bb1 -> bb16 -> bb2  │
│         init x and y        │
╰─────────────────────────────╯
           │
           V
╭────────────────────╮            ╭────────────────╮
│     bb17 -> bb3    │    true    │       bb4      │
│  _16 = true;       │ ─────────> │  _16 = false;  │
│  if id() % 2 == 0  │            │  drop(y);      │
╰────────────────────╯            ╰────────────────╯
         │                             │
         │ false                       │
         V                             V
     ╭───────╮                    ╭──────────╮
     │  bb5  │                    │   bb12   │
     ╰───────╯                    │  y = x;  │
         │                        ╰──────────╯
         │                             │
         │                             │
         │   ╭──────────────────╮      │
         ╰─> │        bb6       │ <────╯
             │  if _16 == true  │
             ╰──────────────────╯
                 │          │ false
            true │          ╰─────╮
                 V                V
      ╭────────────╮          ╭────────────╮
      │     bb7    │ <─────── │    bb13    │
      │  drop(y);  │          │  drop(x);  │
      ╰────────────╯          ╰────────────╯
               │
               │
               V
            ╭──────────╮
            │    bb8   │
            │  return  │
            ╰──────────╯
```

It sets `_16` to `false` when `y` is dropped. It checks `_16` before exiting the function.

### Terminators

So far, we have seen many kinds of terminators. A statement is a terminator if and only if it's the last statement of a basic block. You can see the exhaustive list of terminator kinds [here](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.TerminatorKind.html).

[[anchor, id = terminator kind]][[/anchor]]

If a block has only one successor, it has a [Goto](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.TerminatorKind.html#variant.Goto) terminator (line 35 of [this](#mirex4) example). A condtion of an `if` branch usually uses a [switchInt](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.TerminatorKind.html#variant.SwitchInt) terminator (line 30 of [this](#mirex4) example). [Return](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.TerminatorKind.html#variant.Return) literally returns from the current function (line 45 of [this](#mirex4) example). A function call in MIR always terminates a basic block. It uses [this](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.TerminatorKind.html#variant.Call) terminator (line 9 of [this](#mirex4) example and line 67 of [this](#mirex2) example). If a basic block terminates with a function call, it may have 1 or 2 successors. If the function panics, it has to unwind the stack and call destructors. For panic-able functions, the terminator has a successor for stack unwinding.

[[br]]

### Appendix: implementation of MIR

[GlobalCtxt] is the central data structure that contains all the information of a compilation. It's such a gigantic type and looking at the details of the type is way beyond this article's topic. I'll focus on types that are related to this article.

[Body] is the type that contains all the information of a function, including the [basic_blocks](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/struct.Body.html#structfield.basic_blocks). A basic block has [BasicBlockData], which literally contains the data of it. A [BasicBlockData] consists of [Statement]s and a [Terminator].

[StatementKind] and [TerminatorKind] lists all the possible kinds of statements and terminators. [StatementKind] includes [assignment](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/syntax/enum.StatementKind.html#variant.Assign), [StorageLive](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/syntax/enum.StatementKind.html#variant.StorageLive) and [StorageDead](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/syntax/enum.StatementKind.html#variant.StorageDead). We've seen them in this article. I explained [TerminatorKind] [here](#terminatorkind).

Locals of a [Body] are stored in [local_decls](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/struct.Body.html#structfield.local_decls). Information of a local is defined in [LocalDecl](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/struct.LocalDecl.html).

Debug information (like the one at line 22 of [this](#mirex4) example) of user defined variables are stored [here](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/struct.Body.html#structfield.var_debug_info). [VarDebugInfo](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/struct.VarDebugInfo.html) is the structing containing the debug info.

[GlobalCtxt]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.GlobalCtxt.html
[Body]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/struct.Body.html
[BasicBlockData]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/struct.BasicBlockData.html
[Statement]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/struct.Statement.html
[Terminator]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/terminator/struct.Terminator.html
[TerminatorKind]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/syntax/enum.TerminatorKind.html
[StatementKind]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/syntax/enum.StatementKind.html