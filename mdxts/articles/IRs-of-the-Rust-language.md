---
date: [2023, 5, 7]
tags: [rust, compiler]
preview: The Rust compiler is very complicated. It consists of many modules, and it takes multiple steps to translate a human-readable programming language to a machine code. Though it's not necessary for typical programmers to know the internals of the compiler, it'd be very helpful if we understand how the language works.
---

# IRs of the Rust language

The Rust compiler is very complicated. It consists of many modules, and it takes multiple steps to translate a human-readable programming language to a machine code. Though it's not necessary for typical programmers to know the internals of the compiler, it'd be very helpful if we understand how the language works. In this article, I'll take a closer look at the steps the compiler takes.

[Rust playground](https://play.rust-lang.org) is an excellent place to play around with the compiler-internals. All the IRs in this article are generated by it. I used Rust-1.71.0-nightly, which is the newest version as I write this article.

## Steps of the compilation

When a programmer compiles a Rust code, the code goes through below steps.

```
          Rust
           |
           | Lexer, Parser
           V
  Abstract Syntax Tree
           |
           | Rust Compiler
           V
          HIR
           |
           | Rust Compiler
           V
          MIR
           |
           | Rust Compiler
           V
        LLVM IR
           |
           | LLVM
           V
      Machine Code
```

First, a [lexer] translates a human-readable code to machine-friendly tokens. The tokens are then translated to [AST] by a [parser]. Lexing, parsing and AST are not Rust-specific concepts, so I won't discuss them in this article. If you want to know about them, please refer to the wikipedia links in the article.

The AST is translated to HIR, High-level Intermediate Representation. According to the [documentation][Rust Compiler Overview], HIR is a compiler-friendly AST. It resembles the syntax of Rust very closely, except that it's simplified. HIR is lowered to THIR, Typed High-level Intermediate Representation before converted to MIR. HIR is still quite readable to human. You'll see that in later sections.

The next step is MIR, Mid-level Intermediate Representation. It's a very simplified form. Many optimizations and safety checks are done in this stage. There are [blog post](https://blog.rust-lang.org/2016/04/19/MIR.html) and [documents](https://rustc-dev-guide.rust-lang.org/mir/index.html) explaining the details of MIR; you'd probably enjoy it.

After the compiler does Rust-specific analysis and optimizations on MIR, it's passed to LLVM. From here, everything is up to LLVM, which we're not interested in.

Most information in this section is from [Rust Compiler Overview]. Please refer to the document if you want to know more about the compiler.

[lexer]: https://en.wikipedia.org/wiki/Lexical_analysis
[parser]: https://en.wikipedia.org/wiki/Parsing#Parser
[AST]: https://en.wikipedia.org/wiki/Abstract_syntax_tree
[Rust Compiler Overview]: https://rustc-dev-guide.rust-lang.org/overview.html

[[box]]

Table of contents

Since this article contains very long lines of code, I provide you a Toc here.

[[toc]]

[[/box]]

## HIR

There isn't much change in HIR compared to the original code. Let's see how the compiler translates the fizz-buzz code below to HIR.

```rust, line_num
fn main() {
    for i in 1..200 {
        if i % 15 == 0 { println!("fizzbuzz"); }
        else if i % 3 == 0 { println!("fizz"); }
        else if i % 5 == 0 { println!("buzz"); }
        else { println!("{i}"); }
    }
}
```

```rust, line_num
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
fn main() {
    {
        let _t = match #[lang = "into_iter"](#[lang = "Range"]{ start: 1, end: 200, }) {
            mut iter => loop {
                match #[lang = "next"](&mut iter) {
                    #[lang = "None"] {} => break,
                    #[lang = "Some"] {  0: i } => {
                        if i % 15 == 0 { {
                            ::std::io::_print(<#[lang = "format_arguments"]>::new_const(&["fizzbuzz\n"]));
                        }; }

                        else if i % 3 == 0 { {
                            ::std::io::_print(<#[lang = "format_arguments"]>::new_const(&["fizz\n"]));
                        }; }

                        else if i % 5 == 0 { {
                            ::std::io::_print(<#[lang = "format_arguments"]>::new_const(&["buzz\n"]));
                        }; }

                        else { {
                            ::std::io::_print(
                                <#[lang = "format_arguments"]>::new_v1(
                                    &["", "\n"],
                                    &[<#[lang = "format_argument"]>::new_display(&i)])
                                );
                        }; }
                    }
                }
            },
        };

        _t
    }
}
```

I ran the compiler in release mode, but the debug mode outputs the same HIR because it doesn't optimize when generating HIR.

The first change we notice is an import of preludes. It includes very frequently used names. You can see the exhaustive list of the preludes [here](https://doc.rust-lang.org/stable/std/prelude/index.html). Then, you can see tons of `#[lang = "XXX"]` macros. It looks scary at first, but they are just shortcuts for long names. For example, `#[lang = "Some"]` refers to `Option::Some<T>` defined in the std library. Possible variants of the macro is defined [here](https://github.com/rust-lang/rust/blob/master/compiler/rustc_hir/src/lang_items.rs)[^nolineno]. The table is defined at the end of the code. I have no idea why they use such macro, but let's not get scared. With that in mind, we can understand the above code like below:

1. `1..200` is translated to `Range { start: 1, end: 200 }.into_iter()`.
2. `Range { start: 1, end: 200 }.into_iter()` is assigned to `iter`.
3. It turns `for` into `loop`. In each loop, it matches `iter.next()`
4. If `iter.next()` is `None`, it breaks.
5. If `iter.next()` is `Some(i)`, it runs the fizz-buzz code.
6. `println!` is converted to `::std::io::_print`. You can see the definition of `_print` [here](https://github.com/rust-lang/rust/blob/master/library/std/src/io/stdio.rs)[^nolineno].

[^nolineno]: I didn't include the line number, cause it may change over time.

## MIR

### Example 1: Push an element to a vector

I tried MIR with the fizz-buzz code above, but it was too long. I don't want you guys to suffer scrolling the endless code, so I'll use shorter code.

```rust, line_num
fn main() {
    let mut a = vec![1, 2, 3, 4];
    a.push(5);
}
```

Only 2 lines. I want to see how vector initializaion and push operation are expressed in MIR. Before looking at the MIR, looking at the HIR would be helpful.

```rust, line_num
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;

fn main() {
    let mut a = <[_]>::into_vec(
        #[rustc_box] ::alloc::boxed::Box::new([1, 2, 3, 4])
    );

    a.push(5);
}
```

It turns `vec!` into `into_vec(Box::new())`. See the documents of [Box](https://doc.rust-lang.org/stable/std/boxed/index.html) and [into_vec](https://github.com/rust-lang/rust/blob/master/library/alloc/src/slice.rs)[^nolineno] if you wanna know further.

Below is the MIR of the above code, generated in Debug mode.

```rust, line_num
// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn main() -> () {
    let mut _0: ();                      // return place in scope 0 at src/main.rs:1:11: 1:11
    let mut _1: std::vec::Vec<i32>;      // in scope 0 at src/main.rs:2:9: 2:14
    let mut _2: std::boxed::Box<[i32]>;  // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
    let mut _3: usize;                   // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
    let mut _4: usize;                   // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
    let mut _5: *mut u8;                 // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
    let mut _6: std::boxed::Box<[i32; 4]>; // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
    let _7: ();                          // in scope 0 at src/main.rs:3:5: 3:14
    let mut _8: &mut std::vec::Vec<i32>; // in scope 0 at src/main.rs:3:5: 3:14
    let mut _9: *const [i32; 4];         // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
    let mut _10: *const ();              // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
    let mut _11: usize;                  // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
    let mut _12: usize;                  // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
    let mut _13: usize;                  // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
    let mut _14: usize;                  // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
    let mut _15: bool;                   // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
    scope 1 {
        debug a => _1;                   // in scope 1 at src/main.rs:2:9: 2:14
    }
    scope 2 {
    }

    bb0: {
        _3 = SizeOf([i32; 4]);           // scope 2 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
        _4 = AlignOf([i32; 4]);          // scope 2 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
        _5 = alloc::alloc::exchange_malloc(move _3, move _4) -> bb1; // scope 2 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
                                         // mir::Constant
                                         // + span: /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
                                         // + literal: Const { ty: unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}, val: Value(<ZST>) }
    }

    bb1: {
        _6 = ShallowInitBox(move _5, [i32; 4]); // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
        _9 = (((_6.0: std::ptr::Unique<[i32; 4]>).0: std::ptr::NonNull<[i32; 4]>).0: *const [i32; 4]); // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
        _10 = _9 as *const () (PtrToPtr); // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
        _11 = _10 as usize (Transmute);  // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
        _12 = AlignOf(i32);              // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
        _13 = Sub(_12, const 1_usize);   // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
        _14 = BitAnd(_11, _13);          // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
        _15 = Eq(_14, const 0_usize);    // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
        assert(_15, "misaligned pointer dereference: address must be a multiple of {} but is {}", _12, _11) -> [success: bb7, unwind terminate]; // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
    }

    bb2: {
        _8 = &mut _1;                    // scope 1 at src/main.rs:3:5: 3:14
        _7 = Vec::<i32>::push(move _8, const 5_i32) -> [return: bb3, unwind: bb5]; // scope 1 at src/main.rs:3:5: 3:14
                                         // mir::Constant
                                         // + span: src/main.rs:3:7: 3:11
                                         // + literal: Const { ty: for<'a> fn(&'a mut Vec<i32>, i32) {Vec::<i32>::push}, val: Value(<ZST>) }
    }

    bb3: {
        drop(_1) -> bb4;                 // scope 0 at src/main.rs:4:1: 4:2
    }

    bb4: {
        return;                          // scope 0 at src/main.rs:4:2: 4:2
    }

    bb5 (cleanup): {
        drop(_1) -> [return: bb6, unwind terminate]; // scope 0 at src/main.rs:4:1: 4:2
    }

    bb6 (cleanup): {
        resume;                          // scope 0 at src/main.rs:1:1: 4:2
    }

    bb7: {
        (*_9) = [const 1_i32, const 2_i32, const 3_i32, const 4_i32]; // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
        _2 = move _6 as std::boxed::Box<[i32]> (Pointer(Unsize)); // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
        _1 = slice::<impl [i32]>::into_vec::<std::alloc::Global>(move _2) -> bb2; // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:50:36: 55:10
                                         // mir::Constant
                                         // + span: /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:50:36: 50:51
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(Box<[i32]>) -> Vec<i32> {slice::<impl [i32]>::into_vec::<std::alloc::Global>}, val: Value(<ZST>) }
    }
}
```

A function in MIR consists of locals, scopes and basic blocks.

Locals are values stored on the stack, such as function arguments, local variables and temporary variables. They're underscored numbers. `_0` is the return value of the function. In our code, `_0` is `()` because the main function doesn't return anything. `a` in Rust is assigned to `_1` in MIR. `_2` through `_6` are temporary variables used by the `vec!` macro. `_7` is the return value of `.push` method. Since it returns nothing, `_7`'s type is `()`.

After locals, there are scopes. They represent lexical scopes. They also contains debug information, which you can see in `scope 1` above. It says `a` is the name of `_1`. Scopes include all the debug information of user-defined variables.

Then you see basic blocks. They represent the control flow of the code. The flow starts at `bb0`, which stands for *basic block 0*. Each basic block contains one or more statements. The last statement is called terminator. The terminator tells which block to execute next. We call the next block *successor*. A block may have more than one successor.

`bb0` allocates memory for `a` using [exchange_malloc](https://github.com/rust-lang/rust/blob/master/library/alloc/src/alloc.rs)[^nolineno] and stores the pointer at `_5`. `-> bb1` after the terminator means it should go to `bb1` after executing `bb0`.

`bb1` creates a pointer for `[i32; 4]`, stores it at `_9`, and checks whether the pointer is well aligned. If so, it goes to `bb7`. Otherwise, it terminates. The two successors are in squared brackets after the terminator.

`bb7` initializes the vector, and `bb2` pushes an element. After everything is done, the runtime calls the destructor of the vector by dropping it, then terminates.

[[br]]

What if we run the same code in release mode?

```rust, line_num
// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn main() -> () {
    let mut _0: ();                      // return place in scope 0 at src/main.rs:1:11: 1:11
    let mut _1: std::vec::Vec<i32>;      // in scope 0 at src/main.rs:2:9: 2:14
    let mut _2: std::boxed::Box<[i32]>;  // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
    let mut _3: usize;                   // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
    let mut _4: usize;                   // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
    let mut _5: *mut u8;                 // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
    let mut _6: std::boxed::Box<[i32; 4]>; // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
    let _7: ();                          // in scope 0 at src/main.rs:3:5: 3:14
    let mut _8: &mut std::vec::Vec<i32>; // in scope 0 at src/main.rs:3:5: 3:14
    let mut _9: *const [i32; 4];         // in scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
    scope 1 {
        debug a => _1;                   // in scope 1 at src/main.rs:2:9: 2:14
    }
    scope 2 {
    }
    scope 3 (inlined slice::<impl [i32]>::into_vec::<std::alloc::Global>) { // at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:50:36: 55:10
        debug self => _2;                // in scope 3 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/slice.rs:461:35: 461:39
    }

    bb0: {
        StorageLive(_1);                 // scope 0 at src/main.rs:2:9: 2:14
        StorageLive(_2);                 // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
        _3 = const 16_usize;             // scope 2 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
        _4 = const 4_usize;              // scope 2 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
        _5 = alloc::alloc::exchange_malloc(move _3, move _4) -> bb1; // scope 2 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
                                         // mir::Constant
                                         // + span: /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
                                         // + literal: Const { ty: unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}, val: Value(<ZST>) }
    }

    bb1: {
        _6 = ShallowInitBox(move _5, [i32; 4]); // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
        _9 = (((_6.0: std::ptr::Unique<[i32; 4]>).0: std::ptr::NonNull<[i32; 4]>).0: *const [i32; 4]); // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
        (*_9) = [const 1_i32, const 2_i32, const 3_i32, const 4_i32]; // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:37: 54:46
        _2 = move _6 as std::boxed::Box<[i32]> (Pointer(Unsize)); // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:54:13: 54:47
        _1 = slice::hack::into_vec::<i32, std::alloc::Global>(move _2) -> bb6; // scope 3 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/slice.rs:463:9: 463:29
                                         // mir::Constant
                                         // + span: /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/slice.rs:463:9: 463:23
                                         // + literal: Const { ty: fn(Box<[i32]>) -> Vec<i32> {slice::hack::into_vec::<i32, std::alloc::Global>}, val: Value(<ZST>) }
    }

    bb2: {
        StorageDead(_8);                 // scope 1 at src/main.rs:3:13: 3:14
        drop(_1) -> bb3;                 // scope 0 at src/main.rs:4:1: 4:2
    }

    bb3: {
        StorageDead(_1);                 // scope 0 at src/main.rs:4:1: 4:2
        return;                          // scope 0 at src/main.rs:4:2: 4:2
    }

    bb4 (cleanup): {
        drop(_1) -> [return: bb5, unwind terminate]; // scope 0 at src/main.rs:4:1: 4:2
    }

    bb5 (cleanup): {
        resume;                          // scope 0 at src/main.rs:1:1: 4:2
    }

    bb6: {
        StorageDead(_2);                 // scope 0 at /rustc/74c4821045c68d42bb8b8a7c998bdb5c2a72bd0d/library/alloc/src/macros.rs:55:9: 55:10
        StorageLive(_8);                 // scope 1 at src/main.rs:3:5: 3:14
        _8 = &mut _1;                    // scope 1 at src/main.rs:3:5: 3:14
        _7 = Vec::<i32>::push(move _8, const 5_i32) -> [return: bb2, unwind: bb4]; // scope 1 at src/main.rs:3:5: 3:14
                                         // mir::Constant
                                         // + span: src/main.rs:3:7: 3:11
                                         // + literal: Const { ty: for<'a> fn(&'a mut Vec<i32>, i32) {Vec::<i32>::push}, val: Value(<ZST>) }
    }
}
```

It's way shorter! `bb0` doesn't calculate the size and the alignment of `[i32; 4]` anymore. I guess the compiler calculated it and hard-coded it. There are `StorageDead` and `StorageLive` functions which we didn't see in debug mode. `StorageLive(_1)` tells LLVM that `_1` may be used later. `StorageDead(_1)` means it won't be used anymore. It helps LLVM allocate stack space.

In release mode, it doens't check the alignment of the pointer anymore. It just initializes the vector in `bb1`.

Reference: [RustC Dev Guide](https://rustc-dev-guide.rust-lang.org/mir/index.html)

### Example 2: Adder

Let's do the same thing with another simple code.

```rust, line_num
fn main() {
    add(3, 4);
}

fn foo(a: i32, b: i32) -> i32 {
    if a > b { a + 1 } else { b + 1}
}
```

We don't need HIR this time: it's (almost) identical to the original code. Let's go directly to the MIR.

```rust, line_num
// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn main() -> () {
    let mut _0: ();                      // return place in scope 0 at src/main.rs:1:11: 1:11
    let _1: i32;                         // in scope 0 at src/main.rs:2:5: 2:14

    bb0: {
        _1 = foo(const 3_i32, const 4_i32) -> bb1; // scope 0 at src/main.rs:2:5: 2:14
                                         // mir::Constant
                                         // + span: src/main.rs:2:5: 2:8
                                         // + literal: Const { ty: fn(i32, i32) -> i32 {foo}, val: Value(<ZST>) }
    }

    bb1: {
        return;                          // scope 0 at src/main.rs:3:2: 3:2
    }
}

fn foo(_1: i32, _2: i32) -> i32 {
    debug a => _1;                       // in scope 0 at src/main.rs:5:8: 5:9
    debug b => _2;                       // in scope 0 at src/main.rs:5:16: 5:17
    let mut _0: i32;                     // return place in scope 0 at src/main.rs:5:27: 5:30
    let mut _3: bool;                    // in scope 0 at src/main.rs:6:8: 6:13
    let mut _4: (i32, bool);             // in scope 0 at src/main.rs:6:16: 6:21
    let mut _5: (i32, bool);             // in scope 0 at src/main.rs:6:31: 6:36

    bb0: {
        _3 = Gt(_1, _2);                 // scope 0 at src/main.rs:6:8: 6:13
        switchInt(move _3) -> [0: bb3, otherwise: bb1]; // scope 0 at src/main.rs:6:8: 6:13
    }

    bb1: {
        _4 = CheckedAdd(_1, const 1_i32); // scope 0 at src/main.rs:6:16: 6:21
        assert(!move (_4.1: bool), "attempt to compute `{} + {}`, which would overflow", _1, const 1_i32) -> bb2; // scope 0 at src/main.rs:6:16: 6:21
    }

    bb2: {
        _0 = move (_4.0: i32);           // scope 0 at src/main.rs:6:16: 6:21
        goto -> bb5;                     // scope 0 at src/main.rs:6:5: 6:37
    }

    bb3: {
        _5 = CheckedAdd(_2, const 1_i32); // scope 0 at src/main.rs:6:31: 6:36
        assert(!move (_5.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_i32) -> bb4; // scope 0 at src/main.rs:6:31: 6:36
    }

    bb4: {
        _0 = move (_5.0: i32);           // scope 0 at src/main.rs:6:31: 6:36
        goto -> bb5;                     // scope 0 at src/main.rs:6:5: 6:37
    }

    bb5: {
        return;                          // scope 0 at src/main.rs:7:2: 7:2
    }
}

```

Above is its MIR in debug mode. Let's look at the `foo` function. Two parameters: `a` and `b` are assigned to `_1` and `_2`. You can see their debug info at the top of the function. Its return value is assigned to `_0`, as usual. `_3` is a temporary variable which stores the result of `a > b`.

In `bb0`, it computes the result of `a > b` and stores it at `_3`. If the result is 0, it goes to `bb3`. Otherwise, it goes to `bb1`. In `bb1` and `bb3`, it calls `CheckedAdd`, not just `Add`. The `CheckedAdd` function returns the result and whether it overflowed. That's why the type of `_4` and `_5` are `(i32, bool)`.

After that, it goes to `bb2` or `bb4` where it moves the result to `_0` and returns.

In release mode, it's way simpler. See below.

```rust, line_num
// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn main() -> () {
    let mut _0: ();                      // return place in scope 0 at src/main.rs:1:11: 1:11
    let _1: i32;                         // in scope 0 at src/main.rs:2:5: 2:14

    bb0: {
        StorageLive(_1);                 // scope 0 at src/main.rs:2:5: 2:14
        _1 = foo(const 3_i32, const 4_i32) -> bb1; // scope 0 at src/main.rs:2:5: 2:14
                                         // mir::Constant
                                         // + span: src/main.rs:2:5: 2:8
                                         // + literal: Const { ty: fn(i32, i32) -> i32 {foo}, val: Value(<ZST>) }
    }

    bb1: {
        StorageDead(_1);                 // scope 0 at src/main.rs:2:14: 2:15
        return;                          // scope 0 at src/main.rs:3:2: 3:2
    }
}

fn foo(_1: i32, _2: i32) -> i32 {
    debug a => _1;                       // in scope 0 at src/main.rs:5:8: 5:9
    debug b => _2;                       // in scope 0 at src/main.rs:5:16: 5:17
    let mut _0: i32;                     // return place in scope 0 at src/main.rs:5:27: 5:30
    let mut _3: bool;                    // in scope 0 at src/main.rs:6:8: 6:13

    bb0: {
        StorageLive(_3);                 // scope 0 at src/main.rs:6:8: 6:13
        _3 = Gt(_1, _2);                 // scope 0 at src/main.rs:6:8: 6:13
        switchInt(move _3) -> [0: bb2, otherwise: bb1]; // scope 0 at src/main.rs:6:8: 6:13
    }

    bb1: {
        _0 = Add(_1, const 1_i32);       // scope 0 at src/main.rs:6:16: 6:21
        goto -> bb3;                     // scope 0 at src/main.rs:6:5: 6:37
    }

    bb2: {
        _0 = Add(_2, const 1_i32);       // scope 0 at src/main.rs:6:31: 6:36
        goto -> bb3;                     // scope 0 at src/main.rs:6:5: 6:37
    }

    bb3: {
        StorageDead(_3);                 // scope 0 at src/main.rs:6:36: 6:37
        return;                          // scope 0 at src/main.rs:7:2: 7:2
    }
}
```

I have no idea why `StorageLive` and `StorageDead` only appear in release mode. It's almost identical to the previous MIR, except that it doesn't check the overflow.